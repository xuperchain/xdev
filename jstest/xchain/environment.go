package xchain

import (
	"encoding/json"
	pb "github.com/xuperchain/xupercore/protos"
	"io/ioutil"
	"os"

	"github.com/golang/protobuf/proto"
	"github.com/xuperchain/xupercore/kernel/contract"
	"github.com/xuperchain/xupercore/kernel/contract/bridge"
	//TODO
	_ "github.com/xuperchain/xupercore/bcs/contract/evm"
	_ "github.com/xuperchain/xupercore/bcs/contract/native"
	_ "github.com/xuperchain/xupercore/bcs/contract/xvm"
)

type kcontextImpl struct {
	ctx     *bridge.Context
	syscall *bridge.SyscallService
	contract.StateSandbox
	contract.ChainCore
	used, limit contract.Limits
}

func newKContext(ctx *bridge.Context, syscall *bridge.SyscallService) *kcontextImpl {
	return &kcontextImpl{
		ctx:          ctx,
		syscall:      syscall,
		limit:        ctx.ResourceLimits,
		StateSandbox: ctx.State,
		ChainCore:    ctx.Core,
	}
}

// 交易相关数据
func (k *kcontextImpl) Args() map[string][]byte {
	return k.ctx.Args
}

func (k *kcontextImpl) Initiator() string {
	return k.ctx.Initiator
}

func (k *kcontextImpl) Caller() string {
	return k.ctx.Caller
}

func (k *kcontextImpl) AuthRequire() []string {
	return k.ctx.AuthRequire
}

func (k *kcontextImpl) AddResourceUsed(delta contract.Limits) {
	k.used.Add(delta)
}

func (k *kcontextImpl) ResourceLimit() contract.Limits {
	return k.limit
}

func (k *kcontextImpl) Call(module, contractName, method string, args map[string][]byte) (*contract.Response, error) {
	return &contract.Response{
		Status:  200,
		Message: "ok",
		Body:    nil,
	}, nil
	//var argPairs []*pb.ArgPair
	//for k, v := range args {
	//	argPairs = append(argPairs, &pb.ArgPair{
	//		Key:   k,
	//		Value: v,
	//	})
	//}
	//request := &pb.ContractCallRequest{
	//	Header: &pb.SyscallHeader{
	//		Ctxid: k.ctx.ID,
	//	},
	//	Module:   module,
	//	Contract: contractName,
	//	Method:   method,
	//	Args:     argPairs,
	//}
	//resp, err := k.syscall.ContractCall(context.TODO(), request)
	//if err != nil {
	//	return nil, err
	//}
	//return &contract.Response{
	//	Status:  int(resp.Response.GetStatus()),
	//	Message: resp.Response.GetMessage(),
	//	Body:    resp.Response.GetBody(),
	//}, nil
}

type environment struct {
	xbridge *bridge.XBridge
	model   *mockStore
	//model *sandbox.MemXModel
	basedir string
}

func newEnvironment() (*environment, error) {
	basedir, err := ioutil.TempDir("", "xdev-env")
	if err != nil {
		return nil, err
	}
	store := newMockStore()
	if err != nil {
		return nil, err
	}
	vmconfig := contract.DefaultContractConfig()
	wasmConfig := vmconfig.Wasm
	wasmConfig.Driver = "ixvm"

	xbridge, err := bridge.New(&bridge.XBridgeConfig{
		Basedir: basedir,
		VMConfigs: map[bridge.ContractType]bridge.VMConfig{
			bridge.TypeWasm:   &wasmConfig,
			bridge.TypeNative: &vmconfig.Native,
			bridge.TypeEvm:    &vmconfig.EVM,
		},
		Core:      &chainCore{},
		XModel:    store.NewCache(),
		LogWriter: os.Stderr,
	})
	if err != nil {
		os.RemoveAll(basedir)
		return nil, err
	}

	return &environment{
		xbridge: xbridge,
		model:   store,
		basedir: basedir,
	}, nil
}

type deployArgs struct {
	Name     string                 `json:"name"`
	Code     string                 `json:"code"`
	Lang     string                 `json:"lang"`
	InitArgs map[string]interface{} `json:"init_args"`
	Type     string                 `json:"type"`
	ABIFile  string                 `json:"abi"`
	Options  invokeOptions          `json:"options"`

	trueArgs map[string][]byte
	codeBuf  []byte
}

func convertArgs(ori map[string]interface{}) map[string][]byte {
	ret := make(map[string][]byte)
	for k, v := range ori {
		ret[k] = []byte(v.(string))
	}
	return ret
}

func (e *environment) Deploy(args deployArgs) (*ContractResponse, error) {

	dargs := make(map[string][]byte)
	dargs["contract_name"] = []byte(args.Name)
	dargs["contract_code"] = args.codeBuf

	initArgs, err := json.Marshal(args.trueArgs)
	if err != nil {
		return nil, err
	}
	dargs["init_args"] = initArgs

	descpb := new(pb.WasmCodeDesc)
	descpb.Runtime = args.Lang
	descpb.ContractType = args.Type
	desc, err := proto.Marshal(descpb)
	if err != nil {
		return nil, err
	}
	dargs["contract_desc"] = desc

	ctx := &bridge.Context{
		//ID     int64
		//Module string
		//合约名字
		ContractName: args.Name,

		ResourceLimits: contract.MaxLimits,

		//State ：

		Args: dargs,

		//Method string

		//Initiator string

		//Caller string

		//AuthRequire []string

		CanInitialize: true,

		//Core contract.ChainCore

		//TransferAmount string

		//Instance Instance

		//Logger log15.Logger

		// resource used by sub contract call
		//SubResourceUsed contract.Limits

		// Contract being called
		// set by bridge to check recursive contract call
		//ContractSet map[string]bool

		// The events generated by contract
		//Events []*protos.ContractEvent

		// Write by contract
		//Output *pb.Response

	}

	kctx := &kcontextImpl{
		ctx:          ctx,
		syscall:      nil,
		StateSandbox: e.model,
		ChainCore:    new(chainCore),
		used:         contract.Limits{0, 0, 0, 0},
		limit:        contract.MaxLimits,
	}
	//TODO
	resp, _, err := e.xbridge.DeployContract(kctx)
	if err != nil {
		return nil, err
	}

	return newContractResponse(resp), nil
}

type invokeOptions struct {
	Account string `json:"account"`
	Amount  string `json:"amount"`
}

type invokeArgs struct {
	Method   string                 `json:"method"`
	Args     map[string]interface{} `json:"args"`
	trueArgs map[string][]byte
	Options  invokeOptions
}

func (e *environment) ContractExists(name string) bool {
	//vm, ok := e.xbridge.GetVirtualMachine("wasm")
	//if !ok {
	//	return false
	//}

	//xcache := e.model.NewCache()
	ctx, err := e.xbridge.NewContext(&contract.ContextConfig{
		State: e.model,
		//Initiator:      args.Options.Account,
		//TransferAmount: args.Options.Amount,
		ContractName:   name,
		ResourceLimits: contract.MaxLimits,
	})
	if err != nil {
		//TODO
		return false
	}
	//TODO defer ??
	ctx.Release()
	return true
}

func (e *environment) Invoke(name string, args invokeArgs) (*ContractResponse, error) {
	ctx, err := e.xbridge.NewContext(&contract.ContextConfig{
		State:          e.model,
		Initiator:      args.Options.Account,
		TransferAmount: args.Options.Amount,
		ContractName:   name,

		ResourceLimits: contract.MaxLimits,
	})
	if err != nil {
		return nil, err
	}
	defer ctx.Release()

	resp, err := ctx.Invoke(args.Method, args.trueArgs)
	if err != nil {
		return nil, err
	}

	if resp.Status >= contract.StatusErrorThreshold {
		return newContractResponse(resp), nil
	}

	if err != nil {
		return nil, err
	}

	return newContractResponse(resp), nil
}

func (e *environment) Close() {
	os.RemoveAll(e.basedir)
}

type ContractResponse struct {
	Status  int
	Message string
	Body    string
}

func newContractResponse(resp *contract.Response) *ContractResponse {
	return &ContractResponse{
		Status:  resp.Status,
		Message: resp.Message,
		Body:    string(resp.Body),
	}
}
